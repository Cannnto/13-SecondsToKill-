var cnv = document.createElement("canvas");
        var ctx = cnv.getContext("2d");
        document.body.appendChild(cnv);
        cnv.width = 1024;
        cnv.height = 768;
        document.addEventListener("keydown", kD);
        document.addEventListener("keyup", kU);
        document.addEventListener("mousemove",mM);
        document.addEventListener("mouseup",mU);
        document.addEventListener('contextmenu', a=> {a.preventDefault()})
        var key = [];
        var mou ={
            x:undefined,
            y:undefined
        }
        var ang = 0
        
        function mU(event)
        {   if(event.button == 0)pla.atk = 1;
            if(event.button == 2 && !pla.amo.c) pla.fAk = 1;
        }
        
        function mM(event)
        {   mou.x = event.x- cnv.getBoundingClientRect().left;
            mou.y = event.y- cnv.getBoundingClientRect().top;
        }
        
        function kD(event)
        {   key[event.keyCode] = true;
            //console.log(event.keyCode)
        }
        function kU(event)
        {   key[event.keyCode] = false;
        }
        function r(x,y,w,h,c)
        {   ctx.fillStyle = c;
            ctx.fillRect(x,y,w,h);
        }
        function bal(x,y,r,cor)
        {   ctx.fillStyle = cor
            bP();
            ctx.arc(x, y, r, 0, pi()*2);
            cP();
        }
        function eli(x,y,rw,rh,an,c)
        {   ctx.fillStyle = c;
            bP();
            ctx.ellipse(x, y, rw, rh, an, 0, pi() * 2);
            ctx.fill();
        }
        function d(e, w, h)
        {   return sqr(((e.x+w/2) - (pla.x+pla.w/2))**2 + ((e.y+h/2) - (pla.y+pla.h/2))**2)*bli < dis;}
        
        function drug()
        {   let tx = rng()*(rng()<0.5?1:-1) *rev;
            let ty = rng()*(rng()<0.5?1:-1) *rev;
            t.x+=tx, t.y+=ty, tra(tx,ty);
        
            if(!tx) tra(-t.x, -t.y),t.mtp(0);    
            if(abs(t.x)>2 || abs(t.y)>2)    t.x-=tx, t.y-=ty, tra(-tx,-ty);
        }
        function sgr(name,arr,rcv)
        {   for(var i = 0;i<arr.length;i++)
                for(var j = 0; j<arr[i].length;j++)
                    if(arr[i][j].constructor.name == name)
                        rcv.push(arr[i][j]);
        }
        function shf(arr) 
        {   let I = arr.length;
            // While there remain elements to shuffle...
            while (I)
            {   let rnI = Math.floor(Math.random() * I);
                I--;
        
                [arr[I], arr[rnI]] = [arr[rnI], arr[I]];
            }
        }
        
        function adi(name,arr1)
        {   var arr2 = []
            for(var i = 0; i<arr1.length;i++)
            {   if(arr1[i])
                {arr2[i] = arr1[i][name]}
            }
            return arr2
        }
        
        function dlg(str, clr) {
            r(0, cnv.height-100, cnv.width, 100, "rgba(255,255,255,0.5)");
            r(10, cnv.height-90, cnv.width-20, 80, "rgba(0,0,0,0.5)");
            ctx.fillStyle = clr;
            var tSZ = 20;
            ctx.font = tSZ + "px Arial"; //fonte a mudar
            ctx.textAlign = "center";
            ctx.fillText(str, cnv.width / 2, cnv.height - 45);
        }
        
        function adT(str, clr, tim) {
            var ful = str;
            var ind = ful.indexOf(";")
            var cST = ful.slice(0,ind);
            var rST = ful.slice(ind+1);
            tBX.sTX = cST;
            tBX.aTX = rST;
            tBX.clr = clr;
            tBX.t = tim;
            tBX.cTM = tim;
        }
        
        function dS(event) {
            if (event.keyCode == 67) tBX.t = 0;
            document.removeEventListener("keyup", dS);
        }
        
        function sav(){ctx.save()};
        function res(){ctx.restore()};
        function tra(x,y){ctx.translate(x,y)};
        function scl(x,y){ctx.scale(x,y)};
        function rtt(ang){ctx.rotate(ang)};
        function abs(a){return Math.abs(a)};
        function bP(){ctx.beginPath()};
        function cP()
        {   ctx.closePath()
            ctx.fill();
        };
        function mT(x,y,cor)
        {   ctx.fillStyle = cor;
            bP();
            ctx.moveTo(x,y)
        };
        function lT(x,y){ctx.lineTo(x,y)};
        function rng(){return Math.random()};
        function sin(a){return Math.sin(a)};
        function cos(a){return Math.cos(a)};
        function sqr(a){return Math.sqrt(a)};
        function pi(){return Math.PI};
        function sB(n,c)
        {   ctx.shadowColor = c;
            ctx.shadowBlur = n;
        }
        
        class Atk {
            constructor(nam, tim, act, atm) {
                this.nam = nam;
                this.tmr = {c: 30*tim, m: 30*tim};
                this.act = act;
                this.atm = {c: 30*atm, m: 30*atm};
            }
        }
        
        //frzen 
        function frozen()
        {   for(let i =0; i<fr.c.length; i++)
            {   let x = fr.c[i].x, y = fr.c[i].y, tlI = new Ice(x*32,y*32), tlF = new flr(x*32,y*32);
                
                let a = lvls[clv].map.arr[y][x].add;
                if(fr.a[i].fre != lvls[clv].map.arr[y][x].fre && a) a+=1;
                
                fr.a[i].fre ? lvls[clv].map.arr[y][x] = tlI : lvls[clv].map.arr[y][x] = tlF, lvls[clv].map.arr[y][x].add++;
                    
                if(a==2) {
                    r(x*32,y*32,32,32,'red')
                    fr.p[x*32+y]=undefined, fr.c.splice(i, 1), fr.a.splice(i, 1);
                    i--;
                    continue;   
                }
                
                fr.c[i].cnt++;
                if(fr.c[i].cnt>150)
                {   !fr.a[i].fre ? lvls[clv].map.arr[y][x] = tlI : lvls[clv].map.arr[y][x] = tlF;
                    fr.p[x*32+y]=undefined, fr.c.splice(i, 1), fr.a.splice(i, 1);
                    i--;
                };
                // console.log(fr)
            }
        }
        function setFro(mp,tla)
        {   for(let l=-1;l<2;l++)
            {   for(let c=-1;c<2;c++)
                {   //if(!lvls[clv].map.arr[mp.l+l]) break;
                    let cmp = lvls[clv].map.arr[mp.l+l][mp.c+c];
                    if(fr.p[(mp.c+c)*32+(mp.l+l)]!=tla.fre && cmp.f)
                    {   let p = porra(mp,c,l);
                        if(p)
                            fr.c.splice(p,1), fr.a.splice(p,1);
        
                        fr.c.push({x:mp.c+c, y:mp.l+l, cnt:0});      
                        fr.a.push(tla);
                        fr.p[(mp.c+c)*32+(mp.l+l)]=tla.fre;
                    }
                }
            }
            // console.log(fr)
        }
        function porra(mp,c,l)
        {   for(let i=0;i<fr.c.length;i++){
                // console.log(fr.c[i].x== mp.c+c && fr.c[i].y == mp.l+l)
                if(fr.c[i].x == mp.c+c && fr.c[i].y == mp.l+l)
                    return i;
            }
        }
        class Hud
{   constructor()
    {}
    drw()
    {   
        sB(5,'black');
            //r(32,8,200,80,'rgb(50,50,50,0.5)');
            mT(104,48, 'white');
            lT(104+55,48);
            lT(104+65,48);
            lT(104+55,64);
            lT(104,64);
        cP();
            let c = pla.amo.c/pla.amo.m;
            if(!c) c = 1;
            mT(104,48, 'orange');
            lT(104+55*c,48);
            lT(104+65*c,48);
            lT(104+55*c,64);
            lT(104,64);
        cP();
        
            mT(40+64,32, 'white');
            lT(150+64,32);
            lT(160+64,40);
            lT(150+64,48);
            lT(40+64,48);
        cP();

            mT(104,32, 'red');
            lT(104+110*pla.tim.c/pla.tim.m,32);
            lT(104+120*pla.tim.c/pla.tim.m,40);
            lT(104+110*pla.tim.c/pla.tim.m,48);
            lT(104,48);
        cP();
        sB(0);
        console.log(1*pla.tim.c/pla.tim.m||0.1)
        heF({x:8, y:80, w:128, h:128},1*pla.tim.c/pla.tim.m||0.001);
        
    }
}
function upT(e)
{   for (let i = 0; i < e.length; i++)
    {   e[i].upd();
        if (e[i].die()) e.splice(i, 1), i++;
    }
}
class Par 
{   constructor(e, c, cen)
    { this.x = e.x+rng()*e.w;
      this.y = e.y+rng()*e.h;
      this.vx = -1+rng()*2;
      this.vy = -5+rng()*4;
      this.a = 1;
      this.r = 3;
      this.w = e.w;
      this.h = e.h;
      this.cor = c;
      this.e = e;
      // this.life=0;
      // this.max = 60;
      this.cen = cen;
      if(cen)
      {   var magP = rng()*100;
          var angP = rng()*(2*pi()); 
          var vecP = {x: magP*cos(angP), y: magP*sin(angP)}
          this.x += vecP.x;
          this.y += vecP.y;
      }
    }

    die(){return this.a<0}
    upd() 
    { if(!this.cen)
      { this.upd = function()
        { this.x += this.vx;
          this.y += this.vy*(1-rev*2);
          this.a -= 0.03;
          if(this.r>1) this.r -= 0.05+rng()*0.05;
        }
      }
      else
      {  this.upd = function()
        { var mag = Math.sqrt((this.cen.x - this.x)**2 + (this.cen.y - this.y)**2)/50;
          var ang = Math.atan2((this.cen.y - this.y)*2,(this.cen.x - this.x)*2); 
          var vec = {x: mag * cos(ang)*5, y: mag * sin(ang)*5};

          this.x+=vec.x;
          this.y+=vec.y;
          this.a -= 0.03;
        }
      }
    }
  
    drw()
    { switch (this.cor)
      { case 'red': this.drw = function(){bal(this.x, this.y, this.r, `rgba(${100+rng()*255}, 10, ${10}, ${this.a})`)}
        break;
        case 'ora': this.drw = function(){bal(this.x, this.y, this.r, `rgba(${200+rng()*30}, ${50+rng()*100}, ${10}, ${this.a})`)}
        break;
        case 'pur': this.y=this.e.y+this.e.h;
          this.drw = function(){bal(this.x, this.y, this.r, `rgba(${60+rng()*200}, ${rng()*115}, 255, ${this.a})`)}
        break;
        case 'bla': this.y=this.e.y+this.e.h;
          this.drw = function(){bal(this.x, this.y, this.r, `rgba(${rng()*10}, ${rng()*10}, ${rng()*10}, ${this.a})`)}
        break;
        case 'blu': this.y=this.e.y+this.e.h;
          this.drw = function(){bal(this.x, this.y, this.r, `rgba(${10}, ${50+Math.random()*100}, ${200+Math.random()*30}, ${this.a})`)}
        break;
        case 'gre': this.y=this.e.y+this.e.h;
          this.drw = function(){bal(this.x, this.y, this.r, `rgba(${0+Math.random()*50}, ${100+Math.random()*255}, ${0+Math.random()*50}, ${this.a})`)}
        break;
      } 
      // SCL(this,0.5)
      // ctx.fillStyle = "rgba("+(260-(this.life*2))+","+((this.life*2)+50)+","+(this.life*2)+","+(((this.max-this.life)/this.max)*0.4)+")";
      //blue
      //bal(this.x,this.y,this.r,`rgba(${10}, ${50+Math.random()*100}, ${200+Math.random()*30}, ${this.a})`)
      //red
      //bal(this.x,this.y,this.r,`rgba(${200+rng()*30}, ${50+rng()*100}, ${10}, ${this.a})`)
      //green
      //bal(this.x,this.y,this.r,`rgba(${50+rng()*100}, ${200+rng()*30}, ${10}, ${this.a})`)
      //rainbow
      //bal(this.x,this.y,this.r,`rgba(${rng()*255}, ${rng()*255}, ${rng()*255}, ${this.a})`)
      // res();
    };
}
class Blo
{ constructor(e)
  { this.x = e.x+rng()*e.w;
    this.y = e.y+rng()*e.h;
    this.r = rng()*7.5;
    this.c = `rgb(${100+rng()*155}, 10, ${10})`;
  }
  drw()
  { bal(this.x, this.y, this.r, this.c);
  }
}
var zC = '#3A4A13';
function i(e){return x=e.x, y=e.y, w=e.w, h=e.h;}
function Ddi(arr)
{   let d = 0;
    while(d<10)
    {   let l = parseInt(rng()*22);
        let c = parseInt(rng()*30);
        if(arr[l][c] == 1) arr[l][c] = 11, d++;
    }
}

function mov(e)
{   sav();
    tra(e.x+e.w/2, e.y+e.h/2);
    rtt(e.cnt*pi()/180);
    tra(-(e.x+e.w/2), -(e.y+e.h/2));
}
//change direction
function cha(e)
{   sav();
    if(e.c)
    {   tra(e.x+e.w/2, e.y+e.h/2);
        scl(-1,1);
        tra(-(e.x+e.w/2), -(e.y+e.h/2));
    }
}
//rotate 
function RTT(e,c)
{   sav();
        tra(e.x+e.w/2, e.y+e.h/2);
        rtt(c*pi()/180);
        tra(-(e.x+e.w/2), -(e.y+e.h/2));
}
//scale
function SCL(e,s)
{   sav();
        tra(e.x+e.w/2, e.y+e.h/2);
        scl(s,s);
        tra(-(e.x+e.w/2), -(e.y+e.h/2));
}

function hed(e,a){r(e.x + e.w/4, e.y - e.h/2, e.w/2, e.h/2, `rgba(255,255,255,${a||1})`)};
function pnt(e, color){r(e.x + e.w*0.5/4, e.y+e.h*2.5/4, e.w*3/4, e.h/4, '#055769')};
function shr(e, color){r(e.x + e.w*0.5/4, e.y, e.w*3/4, e.h*1.25/2, color)}
function eye(e, xa, ya, c, color){r(e.x + e.w*xa, e.y - e.h*ya+c, e.w/8, e.h*1.3/8, color)};
function heZ(e,c)
{   i(e);
    r(x + w/4-0.5, y-0.5+c, w/2+1, h/2+1, 'black');
    r(x + w*2/8, y+c, w*3/8, h/2, zC);
    r(x + w*5/8-1, y+h/8+c, w/8+1, h*1.5/4, zC);
}
//------------------Side-----------------    
    //headSide
    function heS(e,b)
    {   i(e);
        hed(e);
        r(x + w*2/8, y - h*4/8, w*4/8, h*0.75/8+1, '#D9D9D9');
        r(x + w*2/8, y - h*3.25/8, w*3/8, h/16+1);
        r(x + w*2/8, y - h*2.75/8, w/8, h/8+1);
        r(x + w*2.5/4, y - h*2.35/8, w/8, h*1.3/8, 'black');

        r(x + w/4, y - h/2, w/2*b, h/10*b, 'red');
        r(x + w/4, y - h/2, w/13*b, h/4*b, 'red');
        r(x + w/3.3, y - h/2, w/13*b, h/6*b, 'red');
        r(x + w/1.7, y - h/2, w/13*b, h/4*b, 'red');
    }
    //HandLeg1Side
    function le1(e, c, cor)
    {   i(e);
        let b = {x:x + w*0.75/4, y:y + h*3/4, w:(w*1.25/4)*2, h:-(h/4)*2}
        RTT(b,c*-5)
            r(b.x, b.y, b.w/2, -b.h/2, cor);
        res();
    }
    function hs1(e,c,cor){i(e), r(x + w*3/4 + c, y, w/4, h/4, cor)};
    function geS(e,c,y1,cor){i(e), r(x + w*4.15/4 - w/14 +c, y + h*y1/7, w/14, h/14,cor)};
    function gaS(e,c)
    {   i(e);
        r(x + w*3/4 + c, y, w/3.5, h/3.5, '#46464b');
        r(x + w*4.15/4 - w/7+c, y + h*1/3.5-h/14, w/7, h/14, 'black');
        geS(e,c,0,'#0000FF');
        geS(e,c,0.1,'#FF0000');
        geS(e,c,0.2,'#00FF00');
    };
    //HandLegs2Side
    function hs2(e, c, cor, at, b)
    {   i(e);
        let a = {x:x + w*2/4, y:y + h*0.5/4-c, w:-(w/4)*2, h:-(h/4)*2};
        RTT(a, c*-10+at);
            r(a.x, a.y, -a.w/2, -a.h/2, cor);
            r(a.x-a.w/2/10, a.y, -a.w/2/1.3*b, -a.h/2/4*b, 'red');
            r(a.x-a.w/2/4, a.y, -a.w/2/4*b, -a.h/2*b, 'red');
        res();
    }
    function le2(e,c,cor,b)
    {   i(e);
        let a = {x: x + w*2/4, y: y + h*3/4, w:-(w*1.25/4)*2, h:-(h/4)*2};
        RTT(a, c*5);
            r(a.x, a.y, -a.w/2, -a.h/2, cor);
            r(a.x-a.w/4, a.y, -a.w/2/2*b, -a.h/2/4*b, 'red');
            r(a.x-a.w/2.70, a.y, -a.w/2/4*b, -a.h/2/1.5*b, 'red');
        res();
    }
    //bodySide
    function bdS(e, coS, coB, z, an)
    {   i(e);
        var a ={x: x + w*0.30/4, y:y, w:w*3.4/4, h: h};
        shr(a,coS);
        if(z)   r(x + w*3/4-0.5, y-0.5+an, w/4+1, h/2+1, 'black'), r(x + w*3/4, y+an, w/4, h/2, zC), eye(e, 7/8, -1.35/8, an,'red');
        if(!z)  r(x + w*3.25/4, y- h*0.1/2, 2, h*1.2/2, '#D9D9D9');
        r(x + w*0.75/4-0.5, y- h*0.1/2-0.5, w*2.5/4+1, h*1.2/2+1, 'black');
        r(x + w*0.75/4, y- h*0.1/2, w*2.5/4, h*1.2/2, coB);
        pnt(a);
    }
//-----------------Back------------------
    //headBac
    function heB(e,b)
    {   i(e);
        hed(e);
        r(x + w*2/8, y - h*4/8, w*4/8, h*2.25/8, '#D9D9D9');
        r(x + w*4/8-1, y - h*4/8-1, (w*2/8+2)*b, (h*4/8+2)*b, zC);
        r(x + w*2/8, y - h*4/8, w*1/16*b, h*2/8*b, 'red');
        r(x + w*2/8, y - h*4/8, w*2/16*b, h*1/12*b, 'red');
    }
    //bodyBack
    function bdB(e,coS,coB,b)
    {   i(e);
        shr(e,coS);

        r(x + w*0.5/4-0.5, y - h*0.1/2-0.5, w*3/4/2+1, h*1.2/2+1, 'black');      
        r(x + w*0.5/4, y - h*0.1/2, w*3/4/2, h*1.2/2, coB);

        r(x + w*0.5/4-0.5, y - h*0.1/2-0.5, (w*3/4+1)*b, (h*1.2/2+1)*b, 'black');      
        r(x + w*0.5/4, y - h*0.1/2, w*3/4*b, h*1.2/2*b, coB);
        pnt(e);
    }
//--------------Front-------------------
    //head
    function heF(e,a)
    {   i(e);
        hed(e,a);
        eye(e, 2.75/8, 2.35/8, 0,`rgba(0,0,0,${a||1})`);
        eye(e, 4.25/8, 2.35/8, 0,`rgba(0,0,0,${a||1})`);
        r(x + w*2/8, y - h*4/8, w*4/8, h*0.75/8, `rgba(217,217,217,${a||1})`);
        r(x + w*5/8, y - h*3.25/8, w/8, h/16);
        r(x + w*2/8, y - h*3.25/8, w/8, h/16);
    }
    function cHe(e)
    {   i(e);
        r(x + w/4-1, y - h/2-1, w/4+2, h/2+2, zC);
        r(x + w*2.4/8, y - h*2.9/8, w/6, h*1.5/8,'red');
        r(x + w*3/4-w/16, y - h/2, w/16, h/4, 'red');
        r(x + w*3/4-w/8, y - h/2, w/8, h/16, 'red');
    }
    function ZhF(e, c)
    {   heZ(e,c);
        eye(e, 2.75/8, -1.35/8, c,'red');
        eye(e, 4.25/8, -1.35/8, c,'red');
    }
    function bdF(e)
    {   i(e);
        shr(e,'#6F6F6F');
        let a = {w:w/4, h:h*1.2/2, y:h*0.1/2};
        r(x + w*0.5/4, y - a.y-0.5, a.w+1, a.h+1,'black');
        r(x + w*0.5/4, y - a.y, a.w, a.h, '#424242');
        r(x + w/3, y - a.y, 2, a.h, '#D9D9D9');
        siJ(e,'#424242');
        pnt(e);    
    }
    //side jacket
    function siJ(e,c1)
    {   i(e);
        let a = {w:w/4, h:h*1.2/2, y:h*0.1/2};
        r(x + w*2.5/4-1, y - a.y-0.5, a.w+1, a.h+1,'black');
        r(x + w*2.5/4, y - a.y, a.w, a.h, c1);
        r(x + w*2/3-2, y - a.y, 2, a.h, '#D9D9D9');
    }
    function han(e,c,x1,at,cor,b)
    {   i(e);
        r(x1 + x, y + h*0.5/4-c+at/4, w/4, h/4, cor);
        r(x1 + x, y + h*0.5/4-c+at/4, w/16*b, h/8*b, 'red');
        r(x1 + x+w*3/16, y + h*0.5/4-c+at/4, w/16*b, h/4.5*b, 'red');
    }
    function gem(e,c,x1,co){ i(e), r(x1+x, y + h*0.4/3.5-c, w/14, h/14,co)};
    function gau(e,c,x1)
    {   //gold
        i(e);
        r(x+x1, y + h*0.35/3.5+c, w/3.5, h/3.5, '#46464b');
        gem(e,-c,x1+w/64 ,'#0000FF');
        gem(e,-c,x1+w/3.5/2-w/14/2,'#FF0000');
        gem(e,-c,x1+w/3.5/2+w/18,'#0000FF');
        if(!(e.a == e.bac)) r(x+w/7+x1, y + h*1.1/3.5+c, w/7, h/14, 'black'), gem(e,-c,x1+w/3.5/2+w/18,'#00FF00');;
        //prata
        // '#C0C0C0';
        // '#636363';
        //aço
        //'#46464b';
        //'#DBDBEB';
        //carmezin
        // '#dc143c';
        // '#481718';        
    }
//-------------
    function HAN(e, c, cor,b)
    {   han(e,-c, 0,0,cor,0);
        
        han(e, c, e.w*3/4,0,cor,b);
    };
    function leg(e, cl, cr, c1,c2,b)
    {   i(e);
        let bl = {x: x + w*0.5/4, y:y + h*3/4, w:w*1.25/4, h:-(h/4)*2}
        let br = {x: x + w*2.25/4, y: bl.y, w: bl.w, h: bl.h};
    
        SCL(bl, cl);
        r(bl.x, bl.y, bl.w, -bl.h/2, c1);
        res();
        
        SCL(br, cr);
        r(br.x, br.y, br.w, -br.h/2, c2);
        r(br.x, br.y, br.w/6*b, -br.h/3*b, 'red');
        r(br.x, br.y, br.w/1.5*b, -br.h/12*b, 'red');
        r(br.x, br.y, br.w/3*b, -br.h/6*b, 'red');
        res();
    };
//----sword draw----
    function swo(e,x1,c,at,cor,f)
    {   i(e);
        let b = {x:x + w*2/4, y:y + h*0.5/4, w:-(w/4)*2, h:-(h/4)*2};
        var s = 0;
        if(e.a!=e.sid)  s=at/4;
        if(e.a==e.sid)  RTT(b, c*-10+at); 
            r(x1 - 2.5, y+h/16-c +s, w/4+5, h/16, 'black');
            r(x1 + w/10, y+h*0.5/4-c +s, w/16, h/4, '#552A18');
            r(x1 + w/16, y+h*1.5/4-c +s, w/8, h/8, '#6F6F6F');
                mT(x1 + w/24, y-h*4/8+0.5-c+s,cor);
                lT(x1 + w/8, y-h*6/8+0.5-c+s);
                lT(x1 + w/4.8, y-h*4/8+0.5-c+s);
            cP();
            r(x1+w/24, y-h/2-c+s, w/6, h*9/16, cor);

        var a = (c*-0*pi()/180)
        if(e.a==e.sid)   res(), a = ((c*-10+at)*pi()/180);
        
        let bl1 = {x:(x1+w/24),y:(y-h/2 - c+s)+20*sin(a),w:w/6,h:h*9/16};
        let bl2 = {x:(x1+w/24)-h*5.1/8,y:(y-h/2 - c)+5*sin(a),w:bl1.h, h:bl1.w}; 
        if(e.c) bl1.x-=w/4, bl2.x+=bl2.w;
        let bl = bl1;
        if(a*180/pi()<-45)   bl = bl2;

        // r(bl1.x,bl1.y,bl1.w,bl1.h, 'purple')
        // r(bl2.x,bl2.y,bl2.w,bl2.h,'purple')
        if(e.dea)   for (let i = 0; i < 5; i++) par.push(new Par(bl, 'red', {x:bl1.x+bl1.w/2, y:bl1.y+bl1.h/2}));
        if(f || bli) for (let i = 0; i < 5; i++) par.push(new Par(bl, 'ora'));
    }
    function sla(e)
    {   i(e);
        ctx.fillStyle = 'red';
        RTT(e, ang*180/pi());
            bP();
                mT(x, y);
                lT(x + w/2, y + h/6);
                lT(x + w, y + h/2);
                lT(x + w/2, y + h/1.2);
                lT(x, y + h);
                lT(x+ w/3, y + h/1.3);
                lT(x+ w/2, y + h/2);
                lT(x+ w/3, y + h/4);
            cP();
        res();
        ctx.fill();
    }
//box
    function box(e)
    {   i(e);
        let a = {x:x+w/2-w/16, y:y+w/3-6, w: w/8, h: h};
        let b = {x:x+w/2-w/16, y:y-7.5, w: w/16, h: h/1.2};
        let li = '#E29628', mli = '#B5701D';
        r(x, y, w, h, '#995F12');
        RTT(a,-60);
            r(a.x,a.y,a.w,a.h, mli);
        res();
        RTT(b,82);
            r(b.x,b.y,b.w,b.h, mli);
        res();
        // r(x,y,w,h/4, '#806D4D');
        r(x+1,y+1,w/8-2,h-2, li);
        r(x+1,y+1,w-2,h/12-2, li);
        r(x+1,y+h/4+1,w-2,h/8-2, li);
        r(x+1+w*0.875,y+1,w/8-2,h-2, li);
        r(x+1,y+h*0.875+1,w-2,h/8-2, li);
    }
    function btn(e, cor)
    {   i(e);
        eli(x+w/2, y+h/2, w/3, h/8, 0, cor);
        eli(x+w/2, y+h/1.2, w/2.5, h/5, 0, 'gray');
        eli(x+w/2, y+h/1.2, w/3, h/8, 0, cor);
        r(x+w/6, y+h/2, w/1.5, h/3, cor);
    }
    function spw(e)
    {   //r(e.x,e.y,e.w,e.h,'red');
        i(e);
        r(x+w/8,y+h/8,w*0.75,h*0.75,'#C6C6C8');
        r(x+w/8,y+h/8,w*0.75/8,h*0.75,'red');
        r(x+w/8,y+h/8,w*0.75/4,h*0.75/2.5,'red');
        r(x+w*0.05,y+h/1.5,w*0.9,h/4,'#D9D9D9');
    }
    function sgn(e)
    {   i(e);
        r(x,y,w,h/1.75,'#7C653C');
        r(x+w/2.2,y,w/8,h,'#7C653C');
        r(x+w*0.1,y+h/1.75*0.5/4,w*0.8,h/3/4,'#574220');
        r(x+w*0.1,y+h/1.75*1.75/4,w*0.8,h/3/4,'#574220');
        r(x+w*0.1,y+h/1.75*3/4,w*0.8,h/3/4,'#574220');
    }
    function int(e)
    {   i(e);
        ctx.font = `${w/2}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillStyle = 'white';
        ctx.fillText('[E]', x+w/2, y-h);
    }
    function lB(e,c,p,w1,d,l)
    {   i(e)
        let ww = (e.lif.c/e.lif.m)*l || 1;
        sB(3,'black');
        mT(x,y-p-d, c);              //b
        lT(x+w*ww,y-p-d);        //b
        lT(x-w1+(w+w1*2)*ww,y-p);//a
        lT(x+w*ww,y-p+d);         //after
        lT(x,y-p+d);              //after
        lT(x-w1,y-p);         //a
        cP();
        sB(0,'black');
    }

    function mor(e)
    {   i(e);
        r(x+w/2-w/1.5/2,y-h/3,w/1.5,h/2,'black');
        ctx.font = `${w}px arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'white';
        ctx.fillText(e.val[e.i%e.val.length], x+w/2, y-h/3);
    }
    function mat(e)
    {   i(e);
        r(x+1,y+1,w-2,h-2,'#30353D');
    }

    function DFb(e)
    {   i(e);
        //r(x,y,w,h,'white');
        Dbd(e,0);
        //hole
        sB(10,'black');
        r(x+w*2/5,y,w/5,h,'black');
        de1(0);
        de2(0);
        RTT(e,180);
            de1(0);
            de2(0);
        res();
        sB(8,'red');
            mT(x+w*2.3/5,y,'#880D41');
            lT(x+w*2.8/5,y);
            lT(x+w*2.5/5,y+h);
            cP();
        sB(0);
        spk(e,0);
        spk(e,w/1.6);
    }
    function DFh(e)
    {   i(e);
    
        //face
        sB(10,'black');
        mT(x+w*1.5/5,y,'black');
        lT(x+w*1.5/5,y-h/3.25);
        lT(x+w*2/5,y-h/2.75);
        lT(x+w*3/5,y-h/2.75);
        lT(x+w*3.5/5,y-h/3.25);
        lT(x+w*3.5/5,y);
        cP();
    
        //eye
        r(x+w/2-w/16/2,y-h/4,w/16,h/32,'#FF8E54');
        r(x+w/2-w/16/2,y-h/4-h/32,w/16,h/32,'#EC082A');
        r(x+w/2-w/16/2,y-h/4+h/32,w/16,h/32,'#EC082A');
        r(x+w/2+w/16/2,y-h/4,w/16,h/32,'#EC082A');
        r(x+w/2-w/5.4/2,y-h/4,w/16,h/32,'#EC082A');
        sB(0);
        
        r(x+w/2+w/16/2,y-h/4+h/32,w/32,h/32,'#670816');
        r(x+w/2+w/16/2,y-h/4-h/32,w/32,h/32,'#670816');
        r(x+w/2-w/8/2,y-h/4+h/32,w/32,h/32,'#670816');
        r(x+w/2-w/8/2,y-h/4-h/32,w/32,h/32,'#670816');
    }
    function Dbd(e,s,b)
    {   i(e);
        
        eli(x+w/2, y-h/12,   w/2.25*!s,h/4.5*!s,0,'#450462');
        eli(x+w/2, y-h/12,   w/2.8*!s,h/4.6*!s,0,'black');
        
        ctx.fillStyle = '#450462';
        bP();
        ctx.ellipse(x+w/2, y-h/12, w/2.25*s,h/4.5*s,0,pi()-(60*pi()/180), pi()*2-(30*pi()/180));
        ctx.fill();
        
        //capuz
        mT(x+w*1/5,y,'#28013A');
        lT(x+w*1.5/5,y-h/2);
        lT(x+w*3.5/5,y-h/2);
        lT(x+w*4/5,y);
        cP();    
    
        eli(x+w/2, y-h/12,   w/2.25*b,h/4.5*b,0,'#450462');
    
        //gola
        mT(x+w*0.9/5, y+h/8,'#450462');
        lT(x+w*0.3/5, y-h/32);
        lT(x+w*4.7/5, y-h/32);
        lT(x+w*4.1/5, y+h/8);
        cP();
    
        //body
        mT(x,y+h,'#450462');
        lT(x+w*1/5,y);
        lT(x+w*4/5,y);
        lT(x+w,y+h);
        cP();    
    
        //detalhe da gola
        mT(x+w*0.9/5, y+h/9, '#28013A');
        lT(x+w*4.1/5, y+h/9);
        lT(x+w*4.2/5, y+h/6);
        lT(x+w*0.8/5, y+h/6);
        cP();
    }
    //details
    function de1(x1)
    {   mT(x1+x+w*1.5/5, y, 'black');
        lT(x1+x+w*2/5,y);
        lT(x1+x+w*2/5,y+h/4);
        lT(x1+x+w*1.8/5,y+h/16);
        cP();
    }
    function de2(x1)
    {   mT(x1+x+w*3.5/5, y, 'black');
        lT(x1+x+w*3/5,y);
        lT(x1+x+w*3/5,y+h/4);
        lT(x1+x+w*3.2/5,y+h/16);
        cP();
    }
    function spk(e,x1)
    {   i(e);
        mT(x1+x,y+h/1,'black');
        lT(x1+x+w/16, y+h/1.15)
        lT(x1+x+w/16, y+h/1.1)
        lT(x1+x+w*1/16, y+h/1.02)
        lT(x1+x+w*2/16, y+h/1.07)
        lT(x1+x+w*2.5/16, y+h/1.02)
        lT(x1+x+w*4/16, y+h/1.08)
        lT(x1+x+w*6/16, y+h/1)
        cP();
    }
    function stf(e,c,b)
    {   i(e);
        e.c = b;
        let x1=0;
        let a = {x:x + w*2/4, y:y + h*0.5/4-c, w:-(w/4)*2, h:-(h/4)*2};
        if(e.a==e.sid) RTT(a, c*-10),x1 = 15;
            cha(e);
                sB(5,'red');
                mT(x+w*3/4-x1, y+h/1.05-c, '#880D41');
                lT(x+w*3.4/4-x1, y+h/5-c);
                lT(x+w*3.5/4-x1, y-h/4-c);
                lT(x+w*4.5/4-x1, y-h/3.5-c);
                lT(x+w*4.75/4-x1, y-h/2-c);
                lT(x+w*5/4-x1, y-h/2-c);
                lT(x+w*4/4-x1, y-h/5-c);
                lT(x+w*3.75/4-x1, y+h/5-c);
                lT(x+w*3.4/4-x1, y+h/1.05-c);
                cP();
                sB(0)
                sB(10,'red')
                bal(x+w*3.75/4-x1, y-h/2-c, w/8, 'white');
                sB(0);
            res();
        if(e.a==e.sid)res();
        e.c = 0;
    }
    function waF(e)
{   i(e);
    r(x,y+h-1,w,1,'black');
    r(x,y,w,1);
    wLi(x, y);
    r(x,y+h*1/3,h,1);
    wLi(x+w*1/8, y+h*1/3);
    r(x,y+h*2/3,h,1);
    wLi(x+w*1/32, y+h*2/3);
    // r(x,y,w,h,'rgba(255,0,0,0.1)');
}
function wLi(x,y)
{   r(x,y,1,10.6);
    r(x+32*1/4,y,1,10.6);
    r(x+32*2/4,y,1,10.6);
    r(x+32*3/4,y,1,10.6);
}
function waS(e)
{   i(e);
    r(x,y,32,32,'#20252E');
    r(x,y,1,32,'#6D798B');
    r(x+31,y,1,32);
    // r(x,y+h-1,w,1,'#6D798B');
    // r(x,y,w,1,'#6D798B');
    // r(x,y,w,h,'rgba(255,0,0,0.1)');

}
function nex(e,dx,dy)
{   i(e);
    // console.log(lvls[clv].map.arr[(y)/32+1][(x)/32+1*dx])
    if(!lvls[clv].map.arr[(y)/32+dy] || !lvls[clv].map.arr[(y)/32+dy][(x)/32+1*dx]) return;
    return lvls[clv].map.arr[(y)/32+dy][(x)/32+1*dx].constructor.name =='Wal';
}
function dir(e,rt)
{   i(e);
    RTT(e,rt);
        r(x+w*0.4/3,y+h*1.6/3,w/5,h/5,'#4C4C4C');
        r(x+w*1.7/3,y+h*2/3,w/3,h/4,'#4C4C4C');
        r(x+w*0.2/3,y+h*0.2/3,w/3,h/3,'#333333');
        r(x+w*2/3,y+h*0.5/3,w/4,h/5,'#333333');
    res();
}
class Vec 
{   constructor(x,y) {
        this.x = x;
        this.y = y;
    }

    sum(v) {
        this.x += v.x;
        this.y += v.y;
    }

    div(v) {
        this.x /= v;
        this.y /= v;
    }

    mtp (v) {
        this.x *= v;
        this.y *= v;
    }

    lim(v) {
        this.x = Math.min(Math.max(this.x, -v), v);
        this.y = Math.min(Math.max(this.y, -v), v);
    }
}
class Ent
{   constructor(x, y, w, h)
    {   this.x = x; 
        this.y = y; 
        this.w = w/2;
        this.h = h/2;

        this.d = new Vec(0,0);
        this.spd = new Vec(0,0);
        this.c = 0;
        this.cnt = 1;
        this.rot = 0;
        this.par = [];
        this.fri = 0;
        this.acel = 0;
    }

    drw()
    {   if(this.d.x){   this.a = this.sid, this.c = 0; if(this.d.x<0) this.c = 1;}
        if(this.d.y>0 && abs(this.d.y)>abs(this.d.x))  this.a = this.fro, this.c=0;
        if(this.d.y<0 && abs(this.d.y)>abs(this.d.x))  this.a = this.bac, this.c=0;

        if(this.spd.x || this.spd.y)
        {   this.cnt++;
            if(this.rot)    this.cnt-=2;

            if(this.cnt>=3 || this.cnt<=-3)this.rot = !this.rot;
        }
        else    this.cnt>0 ? this.cnt-=0.25 : (this.cnt<0 ? this.cnt+=0.25 : null);
        this.a();
        this.lfB();
    }
    lfB(){}
    a(){this.fro()};

    cld(oth)
    {   for(let i=0;i<oth.length;i++)
        {   if (this.x + this.w >= oth[i].x &&     
            this.x <= oth[i].x + oth[i].w &&       
            this.y + this.h >= oth[i].y &&       
            this.y <= oth[i].y + oth[i].h)    return true;
        }
    }
    
    u(o)
    {   return (lvls[clv].map.arr[o.l][o.c].col || lvls[clv].map.arr[o.l][o.c].constructor.name == "dor");}
    
    CWL()
    {   this.mp1 = {c:parseInt((this.x)/32), l:parseInt((this.y)/32)};
        this.mp2 = {c:parseInt((this.x+this.w)/32), l:parseInt((this.y)/32)};
        this.mp3 = {c:parseInt((this.x+this.w)/32), l:parseInt((this.y+this.h)/32)};
        this.mp4 = {c:parseInt((this.x)/32), l:parseInt((this.y+this.h)/32)};
        return (this.u(this.mp1) || this.u(this.mp2) ||this.u(this.mp3) ||this.u(this.mp4));
    }
}
class Pla extends Ent
{   constructor(x,y,w,h)
    {   super(x,y,w,h)
        this.atC = 0;
        this.fAC = 0;
        this.fsw = 0;

        this.bal = [];
        this.msp = 5;
        this.int = 0;
        this.ice = 0;
        this.tim = {c:390, m:390};
        this.amo = {c:0, m:60};
        this.dea = 0;
        this.deC = 0;
    }
    sid()
    {   cha(this);
            //gaS(this,this.cnt);
            hs1(this, this.cnt,'white');
            le1(this, this.cnt,'white');
            mov(this);
                heS(this);
                bdS(this, '#6F6F6F','#424242',0);
            res();
            swo(this, this.x+this.w*2/4, this.cnt, this.atC,'red', this.fsw);
            hs2(this, this.cnt,'white', this.atC,0);
            le2(this, this.cnt,'white',0);
        res();
    }
    bac()
    {   swo(this, this.x, -this.cnt, this.atC,'red', this.fsw);
        
        han(this, -this.cnt, 0, this.atC, 'white',0);
        han(this, this.cnt, this.w*3/4, 0, 'white',0);
        //gau(this, -this.cnt, this.w*3/4)
        leg(this, (this.cnt<0 ? 0.8 : (!this.cnt ? 1 : 1.2)), (this.cnt>0 ? 0.8 : (!this.cnt ? 1 : 1.2)), 'white','white',0);
        
        mov(this);
            heB(this,'#424242');
            bdB(this,'#6F6F6F','#424242', 1);
        res();
    }
    fro()
    {   mov(this);
            heF(this);
            bdF(this);
        res();
        han(this, this.cnt, this.w*3/4, this.atC, 'white',0);
        han(this, -this.cnt, this.w*0/4, 0, 'white',0);
        // HAN(this, this.cnt, 'white', 0);
        swo(this, this.x+this.w*3/4, this.cnt, this.atC,'red', this.fsw);
        //gau(this, this.cnt, 0);
        leg(this, (this.cnt<0 ? 0.8 : (!this.cnt ? 1 : 1.2)), (this.cnt>0 ? 0.8 : (!this.cnt ? 1 : 1.2)), 'white','white',0);
    }
    ATK()
    {   var hit = {x:this.x + 40*this.d.x, y:this.y + 60*this.d.y-this.h/2, w:this.h, h:this.w*1.5};
        //r(this.x + 40*this.d.x, this.y + 60*this.d.y-this.h/2, this.h, this.w*1.5,"red");
        sla(hit);

        for(var i=0; i<lvls[clv].boxes.length; i++)
            if(lvls[clv].boxes[i].box.cld([hit])) lvls[clv].boxes[i].box.x = lvls[clv].boxes[i].box.spX, lvls[clv].boxes[i].box.y = lvls[clv].boxes[i].box.spY;

        for(var i = 0; i<ENE.length; i++)
        {   if(ENE[i].cld([hit]))
                ENE[i].lif.c-=50;
        }
    }
    fir()
    {   this.bal.push(new Ball(this.x+this.w/2, this.y, 16, 16, ang)),this.amo.c++;
    }

    move(o) 
    {   this.x += this.spd.x*abs(this.spd.x/this.len)*o, this.y += this.spd.y*abs(this.spd.y/this.len)*o;}

    upd()
    {   if(this.amo.c) this.amo.c++;
        if(this.amo.c == this.amo.m) this.amo.c = 0;
        //atack animation functions
        if(this.atA)
        {   this.atC+=20;
            this.atk = 0;
            if(!this.atC) this.ATK(), this.atA = 0;
        }        
        if(this.atk)
        {   this.atC-=10;
            if(this.atC<-90) this.atA = 1;
        }
        if(this.fAk && !this.amo.c)
        {   this.fAC++;
            this.fsw = 1;
            if(this.fAC > 30) this.fsw = 0, this.fAC = 0,this.fAk = 0, this.fir();
        }
        //dead checker
        if(this.dea) 
        {   this.deC++;
            if(this.deC > 90)
            {   this.fro = function(){}, this.bac = function(){}, this.sid = function(){};
                swo(this, this.x+this.w/2, -this.cnt, this.atC,'red', this.fsw);
            }
            if(this.deC > 120)  clearInterval(tim);
        }


        if(this.int) int(this);
        this.int = 0; 
        
        this.len = this.spd.x||this.spd.y ? sqr(this.spd.x**2+this.spd.y**2) : 1;
        this.move(1);
        if(this.CWL())this.move(-1), this.spd.mtp(0);
        for(var i=0; i<lvls[clv].boxes.length; i++)
            if(this.cld([lvls[clv].boxes[i].box])) lvls[clv].boxes[i].box.psh(this, this.d.x, this.d.y), this.move(-1);
        
        this.spd.x *= this.fri;
        this.spd.y *= this.fri;
        if(abs(this.spd.x)<0.05) this.spd.x = 0;
        if(abs(this.spd.y)<0.05) this.spd.y = 0;

        
        let mp = {c:parseInt((this.x+this.w/2)/32), l:parseInt((this.y+this.h/2)/32)}
        if(this.ice) setFro(mp, new Ice());
        
        //temporário
        if(key[84])
        {   this.ice = !this.ice;
            key[84] = !key[84];
        }

        if(this.tim.c <= 0) this.dea=1; 
        if(this.tim.c > this.tim.m) this.tim.c = this.tim.m; 
    }
}
class Ball extends Ent
{   constructor(x,y,w,h,a)
    {   super(x,y,w,h);
        this.a = a;
    }
    drw()
    {   r(this.x,this.y,this.w,this.h,'red');
        for (let i = 0; i < 5; i++) par.push(new Par(this, 'ora'));
    }
    die()
    {   if(this.CWL())      return 1;
        for(var i=0; i<lvls[clv].boxes.length; i++)
            if(this.cld([lvls[clv].boxes[i].box])) return 1;

        for(var i = 0; i<ENE.length; i++)
            if(ENE[i].cld([this]))
            {   ENE[i].lif.c-=100;
                return 1;
            }
    }
    upd()
    {   this.x += cos(this.a)*10;
        this.y += sin(this.a)*10;

        let mp = {c:parseInt((this.x+this.w/2)/32), l:parseInt((this.y+this.h/2)/32)}
        // console.log(lvls[clv].map.arr[mp.l][mp.c].fre)
        if(lvls[clv].map.arr[mp.l][mp.c].fre)   setFro(mp, new flr());

    }
}
class Met{
    constructor(dtx,dty,w,h,a) {
        this.dtx = dtx;
        this.dty = dty;
        this.w = w;
        this.h = h;
        this.a = a;
        this.x = cos(a)*(-400)+dtx;
        this.y = sin(a)*(-400)+dty-h;
    }
    upd()
    {   r(this.x,this.y,this.w,this.h,"rgb(161, 81, 35)");
        for (let i = 0; i < 5; i++) par.push(new Par(this, 'ora'));
        this.x += cos(this.a)*10;
        this.y += sin(this.a)*10;
        bal(this.dtx, this.dty, 50, "rgba(255,0,0,"+(((100*this.y)/this.dty)/5)/100+")");
    }
}

class Box extends Ent 
{   constructor(x,y) 
    {   super(x,y,64,64);
        this.spX = x;
        this.spY = y;
    }
    psh(obj)
    {   this.spd.x = obj.spd.x, this.spd.y = obj.spd.y;
    }

    drw()
    {   box(this);
    }

    upd()
    {   this.x += this.spd.x
        this.y += this.spd.y

        if(this.CWL())
        {   this.x -= this.spd.x;
            this.y -= this.spd.y;
            this.spd.x = 0;
            this.spd.y = 0;
        }

        this.spd.x *= this.fri;
        this.spd.y *= this.fri;
        if(abs(this.spd.x)<0.05) this.spd.x = 0;
        if(abs(this.spd.y)<0.05) this.spd.y = 0;
    }

}
class Ene extends Ent
{   constructor(x,y,w,h)
    {   super(x,y,w,h);
        this.anC = 0;
        this.gra = 0;

        this.spe = 1;
        this.spV = new Vec(0,0);
        this.acV = new Vec(0,0);
        this.sVM = 2;
        this.tVM = 1.25;
        this.r = 50;
        //enemy radius
        this.raE = 50;
        //player radius
        this.raP = 300;
        //player max radius
        this.rPM = 500;
        this.wH = 1;
        this.wHa = 1;
    }
    die()
    {  return this.dea;
    }
    wlk(x,y) 
    {   this.x += x;
        this.y += y;
    }
    upd()
    {   //animate functions
        //vetor da soma entre todos os inimigos
        let sV = new Vec(0,0);
        //vetor entre o inimigo e o player
        let tV = new Vec(0,0);
        //cnt inimigos
        let cnt = 0;

        for (let oth of ENE) 
        {   //distancia entre os inimigos
            let d = sqr(((this.x+this.w/2) - (oth.x+oth.w/2))**2 + ((this.y+this.h/2) - (oth.y+oth.h/2))**2);
            //distancia entre o inimigo e o player
            let dp = sqr(((this.x+this.w/2) - (pla.x+pla.w/2))**2 + ((this.y+this.h/2) - (pla.y+pla.h/2))**2);
            
            //persegue o player caso o player esteja dentro do seu raio de detecção
            if (dp <= this.raP) {
                tV = new Vec((pla.x+pla.w/2) - (this.x+this.w/2), (pla.y+pla.h/2) - (this.y+this.h/2));
                this.raP = this.rPM;
            } else {
                //diminui o raio de detecção após o player sair
                if (this.raP > 150) this.raP -= 0.2;
            }

            if (this != oth && d <= this.raP && (oth.raP > this.raP || this.raP > oth.raP)) oth.raP = this.raP;
            

            if (this != oth && d <= this.raE) 
            {   let v = new Vec((this.x+this.w/2) - (oth.x+oth.w/2), (this.y+this.h/2) - (oth.y+this.h/2));
                cnt++;
                sV.sum(v);
            }
            
            if (cnt) sV.div(cnt);
            let s1 = sqr((sV.x)**2 + (sV.y)**2);
            if (s1) sV.div(s1);
            sV.mtp(this.spe*this.sVM);
            
            let s2 = sqr((tV.x)**2 + (tV.y)**2);
            if (s2) tV.div(s2);
            
            tV.mtp(this.spe*this.tVM);
            this.acV.sum(sV);
            this.acV.sum(tV);
            this.spV.sum(this.acV);
            this.spV.lim(this.spe);

            if(this.anC) this.spV.mtp(0), tV.mtp(0);
            this.d = tV;
            this.spd = tV;
        }

        this.wlk(this.spV.x,this.spV.y);
        if(this.CWL()) this.wlk(-this.spV.x, -this.spV.y);   
        for(var i=0; i<lvls[clv].boxes.length; i++)
            if(this.cld([lvls[clv].boxes[i].box])) lvls[clv].boxes[i].box.psh(this, this.d.x, this.d.y), this.wlk(-this.spV.x, -this.spV.y);
        this.acV.mtp(0);

        this.spV.x *= this.fri;
        this.spV.y *= this.fri;
        if(this.spV.x<0.1) this.spV.x = 0;
        if(this.spV.y<0.1) this.spV.y = 0;

        // if(this.cld([pla]) && this.lif.c)
        // {   pla.tim.c-=30;
        //     this.lif.c = 0;
        // }
    }
}
class Min extends Ene
{   constructor(x,y,w,h)
    {   super(x,y,w,h);
        this.lif = {m:100,c:100};
        this.rec = 60;
    }
    sid()
    {   cha(this);
            le1(this, this.cnt, zC);
            mov(this);
                bdS(this, '#5C0C0C', '#5C0C0C',1, this.anC);
            res();
            hs2(this, this.cnt, zC, 0,0);
            le2(this, this.cnt, zC,0);
        res();
    }
    bac()
    {   HAN(this, this.cnt, zC,0);
        leg(this, (this.cnt<0 ? 0.8 : (!this.cnt ? 1 : 1.2)), (this.cnt>0 ? 0.8 : (!this.cnt ? 1 : 1.2)), zC,zC,0);
        
        mov(this);
            bdB(this, '#5C0C0C', '#5C0C0C',1);
        res();
    }
    fro()
    {   mov(this);
            bdB(this, '#5C0C0C', '#5C0C0C',1);
            ZhF(this, this.anC);
        res();
        HAN(this, this.cnt, zC,0);
        leg(this, (this.cnt<0 ? 0.8 : (!this.cnt ? 1 : 1.2)), (this.cnt>0 ? 0.8 : (!this.cnt ? 1 : 1.2)), zC,zC,0);
    }
    lfB()
    {   if(this.y-0.5+this.h/2+1+this.anC > this.y+this.h) this.dea = 1, pla.tim.c+=this.rec;
        if(this.lif.c<=0)
        {   this.gra += 0.25;
            this.anC += this.gra;
            for (let i = 0; i < 5; i++) par.push(new Par(this, 'red'));
            blo.push(new Blo(this));
        }
        else
        {   lB(this, 'white',this.h/4,3,3,0);
            lB(this, 'red',this.h/4,3,3,1);
        } 
    }
}
//currepted
class Cur extends Ene
{   constructor(x,y,w,h)
    {   super(x,y,w,h);
        this.lif = {m:200,c:200};
        this.spd.x = 0;
        this.rec = 90;
    }
    sid()
    {   cha(this);
            le1(this, this.cnt, zC);
            hs1(this, this.cnt, zC);
            mov(this);
                heS(this,1);
                bdS(this, '#5C0C0C', '#B40F0F',0, this.anC);
            res();
            //swo(this, this.x+this.w*2/4, this.cnt, 0,'#4E4E50');
            hs2(this, this.cnt, 'white', 0,1);
            le2(this, this.cnt, 'white',1);
        res();
    }
    bac()
    {   //swo(this, this.x, -this.cnt, 0,'#4E4E50');
        han(this, this.cnt, this.w*3/4,0,zC,0);
        han(this,-this.cnt, 0,0,'white',1);
        leg(this, (this.cnt<0 ? 0.8 : (!this.cnt ? 1 : 1.2)), (this.cnt>0 ? 0.8 : (!this.cnt ? 1 : 1.2)), 'white',zC,0);

        mov(this);
            heB(this,1);
            bdB(this, '#5C0C0C', '#B40F0F',0);
        res();
    }
    fro()
    {   mov(this);
            bdB(this, '#5C0C0C', '#5C0C0C',1);
            heF(this, this.anC);
            cHe(this, this.anC);
            siJ(this, '#B40F0F')
        res();
        // HAN(this, this.cnt, zC);
        han(this, this.cnt, this.w*3/4,0,'white',1);
        han(this,-this.cnt, 0,0,zC,0);
        //swo(this, this.x+this.w*3/4, this.cnt, 0, '#4E4E50');    
        leg(this, (this.cnt<0 ? 0.8 : (!this.cnt ? 1 : 1.2)), (this.cnt>0 ? 0.8 : (!this.cnt ? 1 : 1.2)), zC,'white',1);
    }
    lfB()
    {   if(this.y-0.5+this.h/2+1+this.anC > this.y+this.h) this.dea = 1, pla.tim.c+=this.rec;
        if(this.lif.c<=0)
        {   this.gra += 0.25;
            this.anC += this.gra;
            for (let i = 0; i < 5; i++) par.push(new Par(this, 'red'));
            blo.push(new Blo(this));
        }
        else
        {   lB(this, 'white',this.h/1.3,5,3,0);
            lB(this, 'red',this.h/1.3,5,3,1);
        } 
    }
}
class Dre extends Ene
{   constructor(x,y,w,h)
    {   super(x,y,w,h);
        this.lif = {m:5000,c:5000};
        this.spd.x = 1;
        //flee
        this.fle = true;
        //teleport tile
        this.tpt = []
        //teleport clock
        this.tpc = {c:0, m:30*100};
        this.tpc.c = this.tpc.m;
        //attack stuff
        this.ats = [new Atk("Frb", 0.5, false),
                    new Atk("Wll", 8, false),
                    new Atk("Ice", 10, false),
                    new Atk("Mtr", 6, false, 0.5),
                    new Atk("Aur", 7, false)
        ]; //Fireball, Wall, Ice, Meteor, Aura.
        //fireball array
        this.bal = [];
        //aura radius
        this.auR = 100;
        //meteor tile
        this.mtT = [];
        //meteor array
        this.mtr = [];

    }
    sid()
    {   sB(15*!this.fle,'red');
        cha(this);
            gaS(this,this.cnt);
            tra(0,this.cnt/8)    
                Dbd(this, 1);
                spk(this,0);
                spk(this,this.w/3);
                spk(this,this.w/1.6);
            tra(0,-this.cnt/8)    
            stf(this, this.cnt/5);
            hs2(this, this.cnt/5,'black', 0,0);
        res();
        sB(0);
        for (let i = 0; i < 10; i++) par.push(new Par(this, 'bla'));
    }
    fro()
    {   sB(15*!this.fle,'red');
        tra(0,this.cnt/8);
            DFb(this, this.cnt);
            DFh(this, this.cnt);
        tra(0,-this.cnt/8);
        HAN(this, this.cnt, 'black',0);
        stf(this, this.cnt);
        gau(this, this.cnt, 0);
        sB(0);
        for (let i = 0; i < 10; i++) par.push(new Par(this, 'bla'));
    }
    bac()
    {   sB(15*!this.fle,'red');
        stf(this, -this.cnt,1);
        HAN(this, this.cnt, 'black',0);
        gau(this, -this.cnt, this.w*3/4);
        tra(0,this.cnt/8)    
            Dbd(this, 0, 1);
            spk(this,0);
            spk(this,this.w/3);
            spk(this,this.w/1.6);
        tra(0,-this.cnt/8)   
        sB(0); 
        for (let i = 0; i < 10; i++) par.push(new Par(this, 'bla'));
    }
    lfB()
    {   if(this.y-0.5+this.h/2+1+this.anC > this.y+this.h) this.dea = 1;
        if(this.lif.c<=0)
        {   this.gra += 0.25;
            this.anC += this.gra;
            for (let i = 0; i < 5; i++) par.push(new Par(this, 'red'));
            blo.push(new Blo(this));
        }
        else {
            lB(this, 'white',this.h/1.5,5,4,0);
            lB(this, 'purple',this.h/1.5,5,4,1);
        } 
    }
    tlp() {
        this.tpt = [];
        sgr("flr", lvls[clv].map.arr, this.tpt);
        var chs = this.tpt[parseInt(Math.random()*(this.tpt.length))];
        this.x = chs.x-this.w/2;
        this.y = chs.y-this.h/2;
        let dp = sqr(((this.x+this.w/2) - (pla.x+pla.w/2))**2 + ((this.y+this.h/2) - (pla.y+pla.h/2))**2)
        !this.ats[4].act ? ((this.CWL() || chs.x == undefined || chs.y == undefined || (dp < 250 || dp > 800)) ? this.tlp() : null) : ((this.CWL() || chs.x == undefined || chs.y == undefined || dp > 100) ? this.tlp() : null)
    }
    raG() {
        let slA = Math.floor(Math.random()*(this.ats.length));
        switch (this.ats[slA].nam) {
            case "Frb":
                break;
            case "Wll":
                break;
            case "Ice":
                this.ats[2].act = true;
                this.ats[2].tmr.c = this.ats[2].tmr.m;
                adT("Freeze, insect!;", "purple", 100);
                break;        
            case "Mtr":
                this.ats[3].act = true;
                this.ats[3].tmr.c = this.ats[3].tmr.m;
                this.ats[3].atm.c = this.ats[3].atm.m;
                sgr("flr", lvls[clv].map.arr, this.mtT);
                adT("Behold the heaven's wrath!;", "purple", 100);
                break;
            case "Aur":
                this.ats[4].act = true;
                this.ats[4].tmr.c = this.ats[4].tmr.m;
                adT("Burn, insect!;", "purple", 100);
                break;    
        }
    }
    //set aura
    sAu() {
        let dp = sqr(((this.x+this.w/2) - (pla.x+pla.w/2))**2 + ((this.y+this.h/2) - (pla.y+pla.h/2))**2);
        //bal(this.x+this.w/2,this.y+this.h/2,this.auR,"red");
        if (dp<this.auR) pla.tim.c--;
        this.ats[4].tmr.c--;
        if (this.ats[4].tmr.c == 0) (this.ats[4].act = false, this.fle = true);
    }
    //set ice
    sIc() {
        this.ats[2].tmr.c--;
        if (this.ats[2].tmr.c == 0) (this.ats[2].act = false, pla.ice = 0);
    }
    //set meteor
    sMt() {
        this.ats[3].tmr.c--;
        this.ats[3].atm.c--
        var chs = this.mtT[parseInt(Math.random()*(this.mtT.length))];
        if (this.ats[3].atm.c == 0) this.mtr.push(new Met(chs.x, chs.y, 40, 40, 135*Math.PI/180));
        if (this.ats[3].tmr.c == 0) (this.ats[3].act = false, this.mtT = []);
    }
    upd() {
        this.tpc.c > 0 ? this.tpc.c-- : (this.tpc.c = this.tpc.m, this.raG(), this.tlp());
        //fleeing detector
        this.fle ? ((this.sVM > 0 ? this.sVM *= -1 : null), (this.tVM > 0 ? this.tVM *= -1 : null)) : ((this.sVM < 0 ? this.sVM *= -1 : null), (this.tVM < 0 ? this.tVM *= -1 : null));   
        super.upd();
        if (this.ats[2].act) (pla.ice = 1, this.sIc());
        if (this.ats[3].act) (this.sMt());
        if (this.ats[4].act) (this.fle = false, this.sAu());
        for (let i = 0; i < this.mtr.length; i++) {
            this.mtr[i].upd();
            if (this.mtr[i].y+this.mtr[i].h/2 >= this.mtr[i].dty || this.mtr.x <= this.mtr[i].dtx) this.mtr.splice(i,1), i--;
        }
    }
}
function fill(num)
{   return Array.from({length:24},(i) => Array.from({length:32}, (r)=>num));
}
function cma(arr)
{   for(var lne = 0;lne < arr.length; lne++) // Linhas
    {   for(var col = 0; col < arr[lne].length; col++) // Colunas
        {   switch(Number(arr[lne][col])) // Tipos de Tiles
            {                                  //set X   set Y
                case 1: arr[lne][col] = new flr(col*32,lne*32);break;  // floor
                case 2: arr[lne][col] = new Wal(col*32,lne*32);break;  // wall
                case 3: arr[lne][col] = new dor(col*32,lne*32);break;
                case 4: arr[lne][col] = new Spw(col*32,lne*32);break;
                case 5: arr[lne][col] = new Bxs(col*32,lne*32);break;
                case 6: arr[lne][col] = new Btn(col*32,lne*32,[false,true]);break; 
                case 7: arr[lne][col] = new BDT(col*32,lne*32);break;
                case 8: arr[lne][col] = new Sgn(col*32,lne*32);break;
                //graphics
                case 9: arr[lne][col] = new Gbx(col*32,lne*32);break;
                case 10: arr[lne][col] = new Gbo(col*32,lne*32);break;
                case 11: arr[lne][col] = new Gdi(col*32,lne*32);break;
                //
                case 12: arr[lne][col] = new Ice(col*32,lne*32);break;
                case 13: arr[lne][col] = new Mor(col*32,lne*32,[".","_"], Math.round(rng()));break;
                //mat
                case 14: arr[lne][col] = new Mth(col*32,lne*32,"Dgt", false);break; //random digit tile, mutable
                case 15: arr[lne][col] = new Mth(col*32,lne*32,"Add", true);break;
                case 16: arr[lne][col] = new Mth(col*32,lne*32,"Sub", true);break;
                case 17: arr[lne][col] = new Mth(col*32,lne*32,"Mul", true);break;
                case 18: arr[lne][col] = new Mth(col*32,lne*32,"Div", true);break;
                case 19: arr[lne][col] = new Mth(col*32,lne*32,"Res", true);break; //result tile holds the result of the equation
                case 20: arr[lne][col] = new Mth(col*32,lne*32,"Ans", true);break;
            }
        }
    }
}

function sqlv(arr)
{   for(var y=0;y<cnv.height/32;y++)   arr[y][0] = arr[y][31] = 2;
    for(var x=1;x<cnv.width/32-1;x++)   arr[0][x] = arr[23][x] = 2;
}

function Llvl(arr)
{   sqlv(arr)
    for(var x=0;x<23;x++) arr[11][x] = 2;
    for(var y = 12; y<24;y++) arr[y][22] = 2;
    for(var x=0;x<22;x++)
        for(var y=12;y<24;y++) arr[y][x] = 0;

}
// function Llvl(arr)
// {   sqlv(arr)
//     for(var x=0;x<23;x++) arr[11][x] = 2;
//     for(var y = 24; y<12;y++) arr[y][22] = 2;
//     for(var x=0;x<22;x++)
//         for(var y=24;y<12;y++) arr[y][x] = 0;

// }
function Llvl2(arr)
{   sqlv(arr)
    for(var x=0;x<23;x++) arr[11][x] = 2;
    for(var y = 12; y<24;y++) arr[y][22] = 2;
    for(var x=0;x<22;x++)
        for(var y=12;y<24;y++) arr[y][x] = 0;
}

function Tlvl(arr)
{   sqlv(arr)
    for(var y=1;y<16;y++)
        for(var x=0;x<13;x++)  arr[y+8][x+19] = arr[y+8][x] = 0;
    for(var x=0;x<13;x++) arr[9][x+19] = arr[9][x] = 2;
    for(var y=10;y<24;y++) arr[y][12] = arr[y][19] = 2;
}

function Hlvl(arr)
{   sqlv(arr)
    for(var y=0;y<8;y++)
        for(var x=11;x<21;x++) arr[y][x] = arr[y+16][x] = 0;
    for(var x=11;x<21;x++) arr[16][x] = arr[7][x] = 2;
    for(var y=0;y<7;y++) arr[y][11] = arr[y][20] = arr[y+17][11] = arr[y+17][20] = 2;
}

function Clvl(arr)
{   sqlv(arr)
    for(var y=7;y<17;y++)
        for(var x=10;x<32;x++) arr[y][x] = 0;
    for(var x=10;x<32;x++) arr[16][x] = arr[7][x] = 2;
    for(var y=8;y<16;y++) arr[y][10] = 2;
}

function lv1(arr)
{   //add Walls
    sqlv(arr);
    arr[0][16] = arr[0][15] = 3;
    // arr[1][1] = arr[22][30] = 4;
    // arr[9][9] = arr[9][15] = 5;
    // arr[4][5] = arr[6][5] = arr[4][7] = arr[6][7] = 6;
    // arr[12][9] = arr[12][15] = 7;
    arr[12][28] = 8;
    // let i =0;
    arr[2][23] = arr[2][24] = arr[1][24] = arr[1][25] = 9;
    arr[2][25] = arr[1][22] = arr[1][23] = arr[1][26] = 10;
    // arr[5][30] = arr[22][8] = arr[8][3] = arr[10][20] = 11;

    
    
    // arr[4][10] = new Mth(10*32,4*32,"Dgt", true, 3); //must use this method to create fixed digit tiles
    // arr[4][11] = 15;
    // arr[4][12] = 14;
    // arr[4][13] = 19;
    // arr[4][14] = 20;
    
    Ddi(arr);
    return arr;
}
function lv2(arr)
{   //add Walls
    Llvl(arr);
    arr[0][16] = arr[0][15] = 3;
    arr[1][1] = arr[22][30] = 4;
    arr[3][5] = arr[6][28] = arr[9][9] = arr[9][15] = 5;

    arr[7][1] = arr[16][30] = arr[2][17] = arr[2][14] = 7;

    Ddi(arr);
    return arr;
}
function lv3(arr)
{   //add Walls
    Tlvl(arr);
    arr[0][16] = arr[0][15] = 3;
    // arr[4][5] = arr[6][5] = arr[4][7] = arr[6][7] = 6;

    Ddi(arr);
    return arr;
}
function lv4(arr)
{   //add Walls
    Hlvl(arr);

    var txt = "1: .----;3: ...--;"
    arr[5][5] = new Sgn(5*32,5*32,txt);
    arr[10][10 ] = arr[10][11] = arr[10][12] = arr[10][13] = arr[10][14]  = arr[10][17] = arr[10][18] = arr[10][19] = arr[10][20] = arr[10][21] = 13


    arr[0][6] = arr[0][5] = 3;
    arr[1][1] = arr[22][30] = 4;
    
    Ddi(arr);
    return arr;
}
function lv5(arr)
{   //add Walls
    Clvl(arr);
    arr[0][26] = arr[0][25] = 3;
    arr[12][8] = arr[6][3] = arr[18][28] = arr[4][29] = 6;
    arr[4][9] = arr[16][2] = arr[17][30] = arr[6][30] = 4;

    Ddi(arr);
    return arr;
}
function lv6(arr)
{   //add Walls
    Llvl(arr);
    arr[0][26] = arr[0][25] = 3;
    arr[8][9] = arr[3][20] = 4;

    Ddi(arr);
    return arr;
}
function lv7(arr)
{   Tlvl(arr);
    arr[0][16] = arr[0][15] = 3;

    
    arr[4][22] = 14;
    arr[4][23] = 17;
    arr[4][24] = new Mth(24*32,4*32,"Dgt", true, 3); //must use this method to create fixed digit tiles
    arr[4][25] = 15;
    arr[4][26] = 14;
    arr[4][27] = 19;
    arr[4][28] = 20;


    Ddi(arr);
    return arr;
}
function lv8(arr)
{   Hlvl(arr);
    arr[0][6] = arr[0][5] = 3;
    arr[1][1] = arr[22][30] = 4;
    
    return arr;
}
class lvl 
{   constructor(map,b,r,s)
    {   this.map = map;
        cma(this.map.arr);
        this.boxes = [];
        this.btns=[];
        //boxtile
        this.b = b;
        this.r = r;
        this.boxT = []
        this.maAr = [];
        this.mor = [];
        this.spw = [];
        sgr("Spw", this.map.arr, this.spw);
        sgr("Mor", this.map.arr, this.mor);
        sgr('Bxs', this.map.arr, this.boxes);
        sgr("Btn", this.map.arr, this.btns);
        sgr("BDT", this.map.arr, this.boxT);
        sgr("Mth", this.map.arr, this.maAr);
        shf(this.btns);
        this.mor.sort((a,b) => a.x - b.x);
        for(let i=0;i<this.spw.length;i++)
            this.spw[i].spT = s.t*30, this.spw[i].enL = s.l;
        
        this.txt = ".____...__";
        //box target. target number.        current number 
        // for(var lne = 0;lne < this.map.arr.length; lne++) 
        //     for(var col = 0; col < this.map.arr[lne].length; col++)
        //         if(this.map.arr[lne][col].constructor.name == "Bxs") this.boxes.push(this.map.arr[lne][col].box);
    }

    drw()
    {   this.map.drw();

        bli = this.b;
        rev = this.r;
        //boxcurrentmatch sla n pensei no nome
        //do jeito que tá, o método de passar tá hardcoded, tem que mudar isso ainda
        var bCM = 0;
        for(let i=0; i<this.boxT.length;i++) 
            if (this.boxT[i].act) bCM++;
    
        // //se não tiver caixas ele não passa imediatamente        
        // //bCM == this.boxT.length && bCM != 0?cpd = true:cpd = true;

        // if (this.maAr.length)
        // {   for (let i = 1; i < this.maAr.length; i++) 
        //         this.maAr[i].opr(this.maAr[i-1], this.maAr[i+1]);
            
        //     for (let i=0; i<this.maAr.length; i++) 
        //     {   !this.maAr[i].fix ? this.maAr[i].txC = "crimson" : this.maAr[i].txC = "black";
        //         cpd = 0;
        //         if (this.maAr[this.maAr.length-2].str == 13)
        //         {   this.maAr[i].txC = "green";
        //             cpd = 1;
        //         };
        //     }
        // }
        var tr = 0
        //Checar os switchs para ver se pode passar de level
        for(var i = 0; i<this.mor.length; i++)
        {   if(this.mor[i].val[this.mor[i].i%this.mor[i].val.length] == this.txt[i])  tr++;
            
            if(tr == this.mor.length)
            {   for(var j = 0; j<this.mor.length; j++)
                    this.mor[j].clr = "green";
                    cpd = 1;
            }
            else{
                for(var j = 0; j<this.mor.length; j++)
                    this.mor[j].clr = "red";
            }
        }
    }
}
class Map
{   constructor(arr)
    {   this.arr = arr;
    }

    drw() // Draw
    {   for(var lne = 0;lne < this.arr.length; lne++) // Linhas
            for(var col = 0; col < this.arr[lne].length; col++)
            {   if(this.arr[lne][col] && d(this.arr[lne][col], 32, 32)) this.arr[lne][col].drw();
                
                if(this.arr[lne][col]) this.arr[lne][col].upd(); // Draw each tile 
            }
    }
}
class Tle
{   constructor(x,y)
    {   this.x = x;
        this.y = y;
        this.w = this.h = 32;
        this.add = 0;
        //this.clr = "black"; // Color
        this.tim = {c:0,m:30*3}
    }

    drw() // Draw
    {   ctx.fillStyle = this.clr;
        ctx.fillRect(this.x,this.y,32,32);
    }
    upd(){}
    collide(other)
    {   if (this.x + 32 >= other.x &&
            this.x <= other.x + other.w &&
            this.y + 32 >= other.y &&
            this.y <= other.y + other.h) {
            return true;
        }
        return false;
    }
    uFr()
    {   this.tim.c++;
        if(this.tim.c>this.tim.m)
        {   this.tim.c = 0;
            return 1;
        }
    }

}
class Wal extends Tle
{   constructor(x,y)
    {   super(x,y);
        this.col = true;
    }
    drw()
    {   if(nex(this,1,0) && nex(this,-1,0)) this.drw = function(){ground(this),waF(this)};
        else
        {   if(nex(this,0,-1) && nex(this,0,1)) this.drw = function(){waS(this)}; 
            else
            {   if(!nex(this,0,-1) && !nex(this,0,1))this.drw = function(){waS(this),r(this.x,this.y+this.h-1,this.w,1,'#6D798B'),r(this.x,this.y,this.w,1,'#6D798B')};
                if(nex(this,0,-1))  this.drw = function(){waS(this),r(this.x,this.y+this.h-1,this.w,1,'#6D798B')};
                if(nex(this,0,+1))  this.drw = function(){waS(this),r(this.x,this.y,this.w,1,'#6D798B')};
            }      
        }
    }
}
class flr extends Tle
{   constructor(x,y)
    {   super(x,y);
        this.f = 1;
        this.fre = 0;
    }

    upd()
    {   for(var i = 0; i<frictional.length; i++)
                if(this.collide(frictional[i]))  frictional[i].fri = 0, frictional[i].acel = 5;  
    }
    drw(){ground(this)}
}
class dor extends Tle
{   constructor(x,y)
    {   super(x,y);
        this.clr = "#6b5421";
    }

    upd()
    {   let pbx = {x:pla.x-5,y:pla.y-5,w:pla.w+10,h:pla.h+10};
        //player checker hitbox
        if(this.collide(pbx) && cpd)
        {   clv++;
            pla.x = levels[clv].spwPoint.x;
            pla.y = levels[clv].spwPoint.y;
            ENE = [];
            blo = [];
            par = [];
            pla.bal = [];
        }
    }
}
class Spw extends Tle
{   constructor(x,y) 
    {   super(x,y);
        this.enL = 0;
        this.spT = 0;
        this.cuT = 0;
        this.c = 0;
    }

    arT() 
    {   if(this.cuT == this.spT) 
        {   ENE.push(new Min(this.x,this.y,64,64,this));
            this.cuT = 0;
            this.c++;
        } 
        this.cuT++;
    }
    drw()
    {   ground(this);
        spw(this);
    }
    upd() 
    {   if (this.enL >= ENE.length) this.arT();
    }
}
class Btn extends Tle
{   constructor(x,y)
    {   super(x,y);
        this.clr = "red";
        this.cld = false;
    }

    upd()
    {   if(this.collide(pla))
        {   if(lvls[clv].btns[nxt] == this && !this.cld)
            {   this.clr = "green";
                nxt++;
            }
            else if(!this.cld)
            {   for(var i =0;i<lvls[clv].btns.length;i++)
                    lvls[clv].btns[i].clr = "red";
                nxt = 0;
            }
            this.cld = true;
            if(nxt == 4)    
                cpd = true;
        }
        else
            this.cld = false;
    }
    drw()
    {   ground(this);
        btn(this, this.clr);
    }
}
class Mor extends Tle{
    constructor(x,y,val,i)
    {   super(x,y);
        this.clr = "red";
        this.cld = 0;
        this.val = val;
        this.i = i;
    }

    drw()
    {   ground(this);
        btn(this, this.clr);
        mor(this);
    }

    upd()
    {   if(sqr(((this.x+this.w/2) - (pla.x+pla.w/2))**2 + ((this.y+this.h/2) - (pla.y+pla.h/2))**2)<50)
        {   pla.int = 1;
            if(key[69])
               this.i++, key[69] = !key[69];
        }
    }
}
class Bxs extends Tle {
    constructor (x,y)
    {   super(x,y);
        this.clr = "#FF9633"
        this.box = new Box(this.x,this.y);
    }
}
//box destiny tile
class BDT extends Tle {
    constructor (x,y)
    {   super(x,y);
        this.act = false;
        this.clr = "purple";
    }
    //box collide
    bCD() {
        var len = lvls[clv].boxes.length;
        for (var i = 0; i < len; i++) {
            if (this.x + 32 >= lvls[clv].boxes[i].box.x &&    
                this.x <= lvls[clv].boxes[i].box.x + lvls[clv].boxes[i].box.w &&      
                this.y + 32 >= lvls[clv].boxes[i].box.y &&      
                this.y <= lvls[clv].boxes[i].box.y + lvls[clv].boxes[i].box.h) {
                return true;
            }
        }
        return false;
    }
    upd() {
        this.act = this.bCD();
        this.bCD()?this.clr = "green":this.clr = "purple";
    }
}
//placa Sign
class Sgn extends Tle
{   constructor(x,y,txt)
    {   super(x,y);
        this.clr = '#7C653C';
        this.col = true;
        this.txt = txt
    }
    drw()
    {   ground(this);
        sgn(this);
    }
    upd()
    {   if(sqr(((this.x+this.w/2) - (pla.x+pla.w/2))**2 + ((this.y+this.h/2) - (pla.y+pla.h/2))**2)<50)
        {   if(key[69]) adT(this.txt, "black", 100);
            pla.int = 1;
        }
    }
}
class Ice extends Tle{
    constructor(x,y)
    {   super(x,y);
        this.f = 1;
        this.fre = 1;
    }

    upd()
    {   for(var i = 0; i<frictional.length; i++)
            if(this.collide(frictional[i]))  frictional[i].fri = 0.99, frictional[i].acel = 0.1;    
    }
    drw()
    {   r(this.x,this.y,32,32,"lightblue");
    }
}
class Mth extends Tle{
    constructor(x,y,typ,fix,num)
    {   super(x,y);
        // this.txC = "red";
        this.typ = typ; //Dgt, Add, Sub, Mul, Div, Res, Ans
        this.fix = fix;
        this.fix ? this.txC = "black" : this.txC = "crimson";
        this.val = 0;
        switch (this.typ)
        {   case "Dgt":
                !this.fix ? this.val = Math.floor(Math.random()*21) : this.val = num%21;
                this.dgt = this.val;
            break;
            case "Add":this.dgt = "+";break;
            case "Sub":this.dgt = "-";break;
            case "Mul":this.dgt = "*";break;
            case "Div":this.dgt = "/";break;
            case "Res":this.dgt = "=";break;
            case "Ans":this.dgt = 13;break;       
        }
        this.str = this.val;
    }

    opr(pre,nxt){
        switch (this.typ)
        {   case "Add":nxt.str = pre.str + nxt.val;break;
            case "Sub":nxt.str = pre.str - nxt.val;break;
            case "Mul":nxt.str = pre.str * nxt.val;break;
            case "Div":nxt.str = pre.str / nxt.val;break;
            case "Res":
                this.str = pre.str;
                nxt.str = pre.str;
            break;
            case "Ans":this.str = this.dgt = this.val = 13;break;          
        }
        return;
    }

    chg(num) {
        return(num);
    }

    drw()
    {   mat(this);
        ctx.fillStyle = this.txC;
        ctx.font = `${this.w/1.5}px Arial`; //fonte a mudar
        ctx.textAlign = "center";
        ctx.fillText(this.dgt, this.x+this.w/2, this.y+this.h/2);
    }
    upd(){
        if((sqr(((this.x+this.w/2) - (pla.x+pla.w/2))**2 + ((this.y+this.h/2) - (pla.y+pla.h/2))**2)<50) && !this.fix){
            pla.int = 1;
            if(key[69])
            {   this.val++;
                this.val %= 20;
                this.dgt = this.val;
                this.str = this.val;
                key[69] = false;
            }
        }
    }
}




//graphics
class Gbx extends Tle
{   constructor(x,y)
    {   super(x,y);
        this.col = true;
        this.bx1 = {x:this.x, y:this.y, w:this.w, h:this.h};
        this.bx2 = {x:this.x, y:this.y-this.h/1.4, w:this.w, h:this.h};
    }
    drw()
    {   box(this.bx1);
        box(this.bx2);
    }
}
class Gbo extends Tle
{   constructor(x,y)
    {   super(x,y);
        this.col = true;
    }
    drw(){box(this)};
}
class Gdi extends Tle
{   constructor(x,y)
    {   super(x,y);
        this.r = (90*parseInt(rng()*4));
        this.f = 1;
        this.fre = 0;
    }
    drw()
    {   ground(this);
        
        sB(3,'black');
        dir(this,this.r);
        sB(0);
    };
}
var bli = 0;

    var lvls = [
        new lvl(new Map(lv1(fill(1))),0,0,{t:3,l:50}),
        new lvl(new Map(lv2(fill(1))),0,0,{t:3,l:50}),
        new lvl(new Map(lv3(fill(1))),1,0,{t:3,l:50}),
        new lvl(new Map(lv4(fill(1))),0,0,{t:3,l:50}),
        new lvl(new Map(lv5(fill(1))),0,0,{t:1,l:50}),
        new lvl(new Map(lv6(fill(1))),0,1,{t:1,l:50}),
        new lvl(new Map(lv7(fill(1))),0,0,{t:1,l:50}),
        new lvl(new Map(lv8(fill(12))),0,0,{t:1,l:50}),
    ]
        
    function ground(obj)
    {   //r(obj.x,obj.y,32,1,"rgba(10,10,10,0.1)");
        //r(obj.x,obj.y,1,32,"rgba(10,10,10,0.1)");

        // r(obj.x+1,obj.y+1,15,15,"#1e2636")
        // r(obj.x+17,obj.y+17,15,15,"#1e2636")
        // r(obj.x+1,obj.y+17,15,15,"#1e2636")
        // r(obj.x+17,obj.y+1,15,15,"#1e2636")
        r(obj.x,obj.y,32,32,"#24282E")
    }

    var levels = [
    {
        backPoint:{x:16*32,y:1*32},
    },
    {
        spwPoint:{x:26*32.5,y:21*32},
        backPoint:{x:16*32.5,y:1*32}
    },
    {
        spwPoint:{x:16*31.2,y:21*32},
        backPoint:{x:16*32.5,y:1*32}
    },
    {
        spwPoint:{x:26*31.5,y:21*32},
        backPoint:{x:8*32.5,y:1*32}
    },
    {
        spwPoint:{x:26*32.5,y:21*32},
        backPoint:{x:16*32.5,y:1*32}
    },
    {
        spwPoint:{x:26*32.5,y:21*32},
        backPoint:{x:16*32.5,y:1*32}
    },
    {
        spwPoint:{x:16*31.2,y:21*32},
        backPoint:{x:16*32.5,y:1*32}
    },
    {
        spwPoint:{x:26*31.5,y:21*32},
        backPoint:{x:8*32.5,y:1*32}
    },
    ]
    
    var tBX = {t:0 , sTX: "", aTX: "", clr:"", cTM :0};
    var ENE = [new Dre(100,cnv.height/2,128,128)];
    //new Dre(100,cnv.height/2,128,128);
    //new Cur(100,cnv.height/2,64,64);
    // var nec = new Dre(100,cnv.height/2,128,128);
    var par = [];
    var blo = [];
    var clv = 0;

    var fr = {c:[],a:[],p:[]};


    var cpd = true;
    var nxt = 0;
    var dis = 200;
    var rev = 0;
    var tim = setInterval(loop,1000/30);
    var pla = new Pla(cnv.width/2, cnv.height/4 , 64, 64);
    var All = [];
    var frictional = [];
    var hud = new Hud();
    var t = new Vec(0,0);
    function loop()
    {   r(0,0,cnv.width,cnv.height,'black');
        frictional = ENE.concat(pla,adi("box",lvls[clv].boxes));
        lvls[clv].drw();

        for(let i = 0; i<blo.length; i++)
           if(d(blo[i],0,0))blo[i].drw();
        
        All = ENE.concat(pla, pla.bal,adi("box",lvls[clv].boxes));
        All.sort((a,b) => a.y - b.y);
        for(let i = 0; i<All.length; i++)
            if(d(All[i], All[i].w, All[i].h))    All[i].drw();

        for(let i = 0; i<par.length; i++)
           if(d(par[i],0,0))par[i].drw();

        // upT()
        for(var i = 0;i<adi("box",lvls[clv].boxes).length;i++)
            adi("box",lvls[clv].boxes)[i].upd();
           
        upT(pla.bal);
        upT(ENE);
        upT(par);

        // console.log(fro.a)
        pla.upd();

        frozen();

        // console.log(fro)
        ang = Math.atan2(mou.y - (pla.y), mou.x - (pla.x+pla.w/2)) + pi()*rev||pi()/2;
        pla.d.x = cos(ang);
        pla.d.y = sin(ang);

        if(key[87-rev*4])
            if(pla.spd.y > -pla.msp)
                pla.spd.y -= pla.acel;
                if(pla.spd.y < -pla.msp)pla.spd.y = -pla.msp;
        if(key[83+rev*4])
            if(pla.spd.y < pla.msp)
                pla.spd.y += pla.acel;
                if(pla.spd.y > pla.msp)pla.spd.y = pla.msp;
        if(key[65+rev*3])
            if(pla.spd.x > -pla.msp)
                pla.spd.x -= pla.acel;
                if(pla.spd.x < -pla.msp)pla.spd.x = -pla.msp;
        if(key[68-rev*3])
            if(pla.spd.x < pla.msp)
                pla.spd.x += pla.acel;
                if(pla.spd.x > pla.msp)pla.spd.x = pla.msp;

        // if(key[69]) adT("Fool!;You dare bring light into my lair?;You must die!;", "black", 100); //inicia diálogo
        // if(key[70]) adT("salve!;fml?;é os guri pae;", "red", 30); //inicia diálogo
        (tBX.t) ? (dlg(tBX.sTX, tBX.clr, tBX.t) , tBX.t--, document.addEventListener("keyup", dS)): ((tBX.aTX != "") ? adT(tBX.aTX, tBX.clr, tBX.cTM): null);
        
        hud.drw();
        if(pla.tim.c)pla.tim.c--;

        r(0,0,cnv.width*rev,cnv.height*rev,'rgba(75,0,130,0.4)');
        drug();
    }